import sys
from enum import Enum

# Import the appropriate pyd.
if (sys.version_info > (3, 0)):
    if __package__ or '.' in __name__:
        from . import CoreClient3 as CoreClient
    else:
        import CoreClient3 as CoreClient
else:
    if __package__ or '.' in __name__:
        from . import CoreClient
    else:
        import CoreClient

""" \package ViconDataStream

Contains the main client class and its exception class.
"""

class DataStreamException( Exception ):
    """ Exceptions generated by the data stream.

    The exception class covers the range of errors experienced in
    data stream use.
    """
    def __init__( self, code, additional='' ):
        """ Exception constructor intended for internal use only.

        The exception is thrown by the ViconDataStream class, you need to catch it!
        Individual functions will document the situations that cause errors.
        """
        self.message = {
            CoreClient.Unknown : "Unknown",
            CoreClient.NotImplemented : "NotImplemented",
            CoreClient.Success : "Success",
            CoreClient.InvalidHostName : "InvalidHostName",
            CoreClient.InvalidMulticastIP : "InvalidMulticastIP",
            CoreClient.NullClient : "NullClient",
            CoreClient.ClientAlreadyConnected : "ClientAlreadyConnected",
            CoreClient.ClientConnectionFailed : "ClientConnectionFailed",
            CoreClient.ServerAlreadyTransmittingMulticast : "ServerAlreadyTransmittingMulticast",
            CoreClient.ServerNotTransmittingMulticast : "ServerNotTransmittingMulticast",
            CoreClient.NotConnected : "NotConnected",
            CoreClient.NoFrame : "NoFrame",
            CoreClient.InvalidIndex : "InvalidIndex",
            CoreClient.InvalidCameraName : "InvalidCameraName",
            CoreClient.InvalidSubjectName : "InvalidSubjectName",
            CoreClient.InvalidSegmentName : "InvalidSegmentName",
            CoreClient.InvalidMarkerName : "InvalidMarkerName",
            CoreClient.InvalidDeviceName : "InvalidDeviceName",
            CoreClient.InvalidDeviceOutputName : "InvalidDeviceOutputName",
            CoreClient.InvalidLatencySampleName : "InvalidLatencySampleName",
            CoreClient.InvalidFrameRateName : "InvalidFrameRateName",
            CoreClient.CoLinearAxes : "CoLinearAxes",
            CoreClient.LeftHandedAxes : "LeftHandedAxes",
            CoreClient.HapticAlreadySet : "HapticAlreadySet",
            CoreClient.EarlyDataRequested : "EarlyDataRequested",
            CoreClient.LateDataRequested : "LateDataRequested",
            CoreClient.InvalidOperation : "InvalidOperation",
            CoreClient.NotSupported : "NotSupported",
            CoreClient.ConfigurationFailed : "ConfigurationFailed",
            CoreClient.NotPresent : "NotPresent" }[ code ]

        self.additional = additional

    def __str__( self ):
        """Stringify the execption.

        Reports an error message.
        """
        errorReport = self.message
        if self.additional:
            errorReport = self.message + ' ' + self.additional
        return errorReport


class Client:
    """Vicon DataStream SDK client.`

    This class manages connection to the Vicon tracking data.
    """

    def __init__( self ):
        """The Constructor.

        You can create many instances of the Vicon DataStream Client which can connect to multiple Vicon DataStream Servers.

        The Client is implicitly destroyed as it goes out of scope.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
        """
        self.client = CoreClient.VClient()

    def GetVersion( self ):
      """ Get the version of the client SDK in use.

          >>> import ViconDataStream
          >>> client = ViconDataStream.Client()
          >>> client.GetVersion()
          (1, 7, 0)

      \return A tuple (Major, Minor, Point).

      Note: This is not the version of the server application.
      """
      v = self.client.GetVersion()
      return ( v[0], v[1], v[2] )

    def Connect( self, hostname ):
        """ Establish a dedicated connection to a Vicon DataStream Server.

        See Also : ConnectToMulticast, Disconnect, IsConnected.

        The function defaults to connecting on port 801.
        You can specify an alternate port number after a colon.
        This is for future compatibility, current products serve data on port 801 only.

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.Connect( "localhost" )

        \param  HostName The DNS identifiable name, or IP address of the PC hosting the DataStream server.
                         For example:
                         + "localhost"
                         + "MyViconPC:801"
                         + "10.0.0.2"

        The function will throw DataStreamException if there is a problem:
                + InvalidHostName
                + ClientAlreadyConnected
                + ClientConnectionFailed
        """
        internal = self.client.NewClient()
        ret = self.client.Connect( internal, hostname )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )


    def ConnectToMulticast( self, localIP, multicastIP ):
        """ Connect to a Vicon DataStream Server's Multicast stream.

        The stream content is managed by a client who calls StartTransmittingMulticast().

        See Also : Connect, Disconnect, IsConnected, StartTransmittingMulticast, StopTransmittingMulticast

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.ConnectToMulticast( "localhost", "224.0.0.0" )

        \param  localIP      The DNS identifiable name, or IP address of the local Ethernet interface
                             on which you wish to receive multicast data.
                             You should not specify a port (any port specified will be ignored).
                             For example:
                             + "localhost"
                             + "10.0.0.2"

        \param  multicastIP  The IP Address of the Multicast group on which data will be received.
                             The address should be in the range "224.0.0.0" - "239.255.255.255"
                             You may also specify a port by appending it to the end of the IP Address
                             after a colon. e.g. 224.0.0.0:30001.
                             If you do not specify a port it will default to 44801.

        \throw An DataStreamException class containing the error:
                The Result will be:
                + InvalidHostName
                + InvalidMulticastIP
                + ClientAlreadyConnected
                + ClientConnectionFailed
        """

    def IsConnected( self ):
        """ Is the client connected to the server?

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.IsConnected()
             False
             >>> client.Connect("localhost")
             >>> client.IsConnected()
             True

        \return *True* if the connection to the server is live, *False* otherwise.

        See Also : Connect, Disconnect
        """
        return self.client.IsConnected()

    def Disconnect( self ):
        """ Breaks the connection with the server application.

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.Connect("localhost")
             >>> client.IsConnected()
             True
             >>> client.Disconnect()
             >>> client.IsConnected()
             False

        \throw DataStreamException if the client is not connected.
        """
        ret = self.client.Disconnect()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def StartTransmittingMulticast( serverIP, multicastIP ):
        """ Ask the DataStream Server to start transmitting the data you are receiving directly to a Multicast address as well.

        This allows multiple clients to connect to your stream (via ConnectToMulticast() ) whilst minimizing network
        bandwidth use and frame delivery latency.

        See Also : Connect, ConnectToMulticast, Disconnect, StopTransmittingMulticast

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.Connect( "localhost" )
             >>> client.StartTransmittingMulticast( "10.0.0.1", "224.0.0.0" );

        \param  serverIP      The IP Address of the server Ethernet interface from which the Multicast data will be sent.
                              You should not specify a port number (any port number specified will be ignored).

        \param  multicastIP   The IP Address of the Multicast group to which multicast data will be sent.
                              The address should be in the range 224.0.0.0 - 239.255.255.255. You may also specify
                              the port the data will be sent to by appending it to the IP Address after a colon
                              e.g. 224.0.0.0:30001. If you do not specify a port it will default to 44801.

        \throw A DataStreamException class containing the error:
                + NotConnected
                + InvalidMulticastIP
                + ServerAlreadyTransmittingMulticast

        """
        ret = self.client.StartTransmittingMulticast( serverIP, multicastIP )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def StopTransmittingMulticast():
        """Ask the DataStream Server to stop transmitting the data you are receiving directly to a Multicast address as well.
        You must previously have started a transmission via StartTransmittingMulticast.

        See Also : Connect, ConnectToMulticast, Disconnect, StartTransmittingMulticast

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.Connect( "localhost" );
             >>> client.StartTransmittingMulticast( "10.0.0.1", "224.0.0.0" );
             >>> # Do some stuff
             ...
             >>> client.StopTransmittingMulticast()

        \throw A DataStreamException class containing the error:
                + NotConnected
                + ServerNotTransmittingMulticast
        """
        ret = self.client.StopTransmittingMulticast()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def SetBufferSize( self, size ):
        """ Set the number of frames that the client should buffer.

        The default value is 1 which always supplies the latest frame.
        Choose higher values to reduce the risk of missing frames between calls
        to GetFrame().
        """
        self.client.SetBufferSize( size )


    ##\name Data Enable
    ## The various types of data the SDK provides can be enabled and disabled independently.
    ##
    ## To improve performance the SDK only requests data from the server that have
    ## been explicitly enabled.
    ##\{

    def EnableSegmentData( self ):
        """ Enable kinematic segment data in the Vicon DataStream.

        You should call this function on startup, after connecting to the server,
        and before trying to read local or global segment data.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.EnableSegmentData()
            >>> client.GetFrame()
            >>> client.GetSegmentGlobalTranslation("Alice","Root")
            ((-522.2945270748643, -1.56943597526001, 1119.1174983031265), False)

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also : IsSegmentDataEnabled, DisableSegmentData, EnableMarkerData,
                   EnableUnlabelledMarkerData, EnableDeviceData, GetSegmentCount, GetSegmentName,
                   GetSegmentGlobalTranslation, GetSegmentGlobalRotationXXX, GetSegmentLocalTranslation,
                   GetSegmentLocalRotationXXX
        """
        ret = self.client.EnableSegmentData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def EnableLightweightSegmentData(self):
        """ Enable a lightweight transmission protocol for kinematic segment data in the Vicon DataStream. 

        This will reduce the network bandwidth required to transmit segment data to approximately a quarter of that required by the 
        previous method, at the expense of a small amount of precision.
        Use the existing methods such as GetSegmentGlobalTranslation() and GetSegmentGlobalRotationMatrix() as usual to obtain the segment data.
        Calling this method will automatically disable all other configurable output types. These may be re-enabled after the call if required.
    
        Call this function on startup, after connecting to the server, and before trying to read local or global segment data.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.EnableLightweightSegmentData()
            >>> client.GetFrame()
            >>> client.GetSegmentGlobalTranslation("Alice","Root")
            ((-522.2945270748643, -1.56943597526001, 1119.1174983031265), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
        """
        ret = self.client.EnableLightweightSegmentData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def EnableMarkerData( self ):
        """ Enable labeled reconstructed marker data in the Vicon DataStream. 
        Call this function on startup, after connecting to the server, and before trying to read labeled marker data.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.EnableMarkerData()
    
        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsMarkerDataEnabled(), DisableMarkerData(), EnableSegmentData(), EnableUnlabeledMarkerData(), EnableDeviceData(), GetMarkerCount(), GetMarkerName(), GetMarkerGlobalTranslation()
        """
        ret = self.client.EnableMarkerData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def EnableUnlabeledMarkerData( self ):
        """ Enable unlabeled reconstructed marker data in the Vicon DataStream. 
        Call this function on startup, after connecting to the server, and before trying to read global unlabeled marker data.
    
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.EnableUnlabeledMarkerData()

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsUnlabeledMarkerDataEnabled(), DisableUnlabeledMarkerData(), EnableSegmentData(), EnableMarkerData(), EnableDeviceData(), GetUnlabeledMarkerCount(), GetUnlabeledMarkerGlobalTranslation()
        """
        ret = self.client.EnableUnlabeledMarkerData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def EnableMarkerRayData( self ):
        """  Enable information about the rays contributing to each labeled marker in the Vicon DataStream. 
        Call this function on startup, after connecting to the server, and before trying to read global unlabeled marker data.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.EnableMarkerRayData()

        \throw A DataStreamException class containing the error:
                + NotConnected
        """
        ret = self.client.EnableMarkerRayData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def EnableDeviceData( self ):
        """  Enable force plate, EMG, and other device data in the Vicon DataStream. 
        Call this function on startup, after connecting to the server, and before trying to read device information.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.EnableDeviceData()

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsDeviceDataEnabled(), DisableDeviceData(), EnableSegmentData(), EnableMarkerData(), EnableUnlabeledMarkerData(), GetDeviceCount(), GetDeviceName(), GetDeviceOutputCount(), GetDeviceOutputName(),GetDeviceOutputValue()
        """
        ret = self.client.EnableDeviceData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def EnableCentroidData( self ):
        """ Enable centroid data in the Vicon DataStream.
        Call this function on startup, after connecting to the server, and before trying to read centroid information.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.EnableCentroidData()

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsCentroidDataEnabled(), DisableCentroidData()
        """
        ret = self.client.EnableCentroidData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    ##\}    

    ##\name Data Disable
    ##\{

    def DisableSegmentData( self ):
        """Disable kinematic segment data in the Vicon DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.DisableSegmentData() 
        
        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsSegmentDataEnabled(), EnableSegmentData(), EnableMarkerData(), EnableUnlabeledMarkerData(), EnableDeviceData(), GetSegmentCount(), GetSegmentName(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationEulerXYZ()
        """
        ret = self.client.DisableSegmentData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )


    def DisableLightweightSegmentData(self):
        """ Disable the lightweight output mode for kinematic segment data in the Vicon DataStream.
        Calling this mode does not automatically enable any other data types. If you require non-lightweight
        segment data, call EnableSegmentData()
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.DisableLightweightSegmentData() 

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: EnableLightweightSegmentData, IsLightweightSegmentDataEnabled(), EnableSegmentData(), EnableMarkerData(),
        EnableUnlabeledMarkerData(), EnableDeviceData(), GetSegmentCount(), GetSegmentName(), GetSegmentGlobalTranslation(),
        GetSegmentGlobalRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationEulerXYZ()
        """
        ret = self.client.DisableLightweightSegmentData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
    
    def DisableMarkerData( self ):
        """Disable labeled reconstructed marker data in the Vicon DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.DisableMarkerData() 
        
        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsMarkerDataEnabled(), EnableMarkerData(), EnableSegmentData(), EnableUnlabeledMarkerData(), EnableDeviceData(), GetMarkerCount(), GetMarkerName(), GetMarkerGlobalTranslation()
        """
        ret = self.client.DisableMarkerData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def DisableUnlabeledMarkerData( self ):
        """ Disable unlabeled reconstructed marker data in the Vicon DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.DisableUnlabeledMarkerData()

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsUnlabeledMarkerDataEnabled(), EnableUnlabeledMarkerData(), EnableSegmentData(), EnableMarkerData(), EnableDeviceData(), GetUnlabeledMarkerCount(), GetUnlabeledMarkerGlobalTranslation()
        """
        ret = self.client.DisableUnlabeledMarkerData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def DisableMarkerRayData( self ):
        """ Disable ray contribution data for markers in the Vicon DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.DisableMarkerRayData()

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsMarkerRayDataEnabled(), EnableMarkerRayData(), EnableSegmentData(), EnableMarkerData(), EnableDeviceData(), GetUnlabeledMarkerCount(), GetUnlabeledMarkerGlobalTranslation()
        """
        ret = self.client.DisableMarkerRayData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def DisableDeviceData( self ):
        """ Disable force plate, EMG, and other device data in the Vicon DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.DisableDeviceData()

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsDeviceDataEnabled(), EnableDeviceData(), EnableSegmentData(), EnableMarkerData(), EnableUnlabeledMarkerData(), GetDeviceCount(), GetDeviceName(), GetDeviceOutputCount(), GetDeviceOutputName(), GetDeviceOutputValue()
        """
        ret = self.client.DisableDeviceData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def DisableCentroidData( self ):
        """ Disable centroid data in the Vicon DataStream.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> client.DisableCentroidData()

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: IsCentroidDataEnabled(), EnableCentroidData()
        """
        ret = self.client.DisableCentroidData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )


    ##\}

    ##\name Is Enabled
    ##\{

    def IsSegmentDataEnabled( self ):
        """ Return whether kinematic segment data is enabled in the Vicon DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> if client.IsSegmentDataEnabled() is True:
            >>>     print( "Segment Data Enabled" )
        
        See Also: EnableSegmentData(), DisableSegmentData(), IsMarkerDataEnabled(), IsUnlabeledMarkerDataEnabled(), IsDeviceDataEnabled()
        """
        return self.client.IsSegmentDataEnabled()

    def IsLightweightSegmentDataEnabled(self):
        """ Return whether the lightweight transport mode for kinematic segment data is enabled in the Vicon DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> if client.IsLightweightSegmentDataEnabled() is True:
            >>>     print( "Lightweight Segment Data Enabled" )
        
        
        See Also: EnableSegmentData(), DisableSegmentData(), IsMarkerDataEnabled(), IsUnlabeledMarkerDataEnabled(), IsDeviceDataEnabled()
        """
        return self.client.IsLightweightSegmentDataEnabled()

    def IsMarkerDataEnabled( self ):
        """ Return whether labeled reconstructed marker data is enabled in the DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> if client.IsMarkerDataEnabled() is True:
            >>>     print( "Marker Data Enabled" )
        
        
        See Also: EnableMarkerData(), DisableMarkerData(), IsSegmentDataEnabled(), IsUnlabeledMarkerDataEnabled(), IsDeviceDataEnabled()
        """
        return self.client.IsMarkerDataEnabled()

    def IsUnlabeledMarkerDataEnabled( self ):
        """ Return whether unlabeled marker data is enabled in the DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> if client.IsUnlabeledMarkerDataEnabled() is True:
            >>>     print( "Unlabeled Marker Data Enabled" )
        
        
        See Also: EnableUnlabeledMarkerData(),DisableUnlabeledMarkerData(), IsSegmentDataEnabled(), IsMarkerDataEnabled(), IsDeviceDataEnabled()
        """
        return self.client.IsUnlabeledMarkerDataEnabled()

    def IsMarkerRayDataEnabled( self ):
        """ Return whether marker ray data is enabled in the DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> if client.IsMarkerRayDataEnabled() is True:
            >>>     print( "Marker Ray Data Enabled" )
        
        
        See Also: EnableMarkerRayData(), DisableMarkerRayData(), IsSegmentDataEnabled(), IsMarkerDataEnabled(), IsDeviceDataEnabled()
        """
        return self.client.IsMarkerRayDataEnabled()

    def IsDeviceDataEnabled( self ):
        """ Return whether force plate, EMG, and other device data is enabled in the DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> if client.IsDeviceDataEnabled() is True:
            >>>     print( "Device Data Enabled" )
        
        
        See Also: EnableDeviceData(), DisableDeviceData(), IsSegmentDataEnabled(), IsMarkerDataEnabled(), IsUnlabeledMarkerDataEnabled()
        """
        return self.client.IsDeviceDataEnabled()

    def IsCentroidDataEnabled( self ):
        """ Return whether Centroid data is enabled in the DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect("localhost")
            >>> if client.IsCentroidDataEnabled() is True:
            >>>     print( "Centroid Data Enabled" )
        
        """
        return self.client.IsCentroidDataEnabled()

    ##\}

    class StreamMode( Enum ):
        EClientPull = 0
        EClientPullPreFetch = 1
        EServerPush = 2

    def SetStreamMode( self, streamMode ):

        """ Set the mode of operation of the client.

        There are three modes that the SDK can operate in. Each mode has a different impact on the Client, Server,
        and network resources used.

        In "ServerPush" mode, the Server pushes every new frame of data over the network to the Client. The Server
        will try not to drop any frames. This results in the lowest latency we can achieve. If the Client is unable
        to read data at the rate it is being sent, then it is buffered, firstly in the Client, then on the TCP/IP
        connection, and then at the Server. Once all buffers have filled up then frames may be dropped at the Server
        and the performance of the Server may be affected. The GetFrame() method will return the most recently
        received frame if available, or block the calling thread if the most recently received frame has
        already been processed.

        In "ClientPull" mode, the Client waits for a call to GetFrame(), and then request the latest frame of data
        from the Server. This increases latency, because we need to send a request over the network to the Server,
        the Server has to prepare the frame of data for the Client, and then we need to send the data back over
        the network. Network bandwidth is kept to a minimum, because the Server only sends what you need. We are
        very unlikely to fill up our buffers, and Server performance is unlikely to be affected. The GetFrame()
        method blocks the calling thread until the frame has been received.

        "ClientPullPreFetch" is an enhancement to "ClientPull" mode. A thread in the SDK continuously and
        preemptively does a "ClientPull" on your behalf, storing the latest requested frame in memory.
        When you next call GetFrame(), the SDK returns the last requested frame which we had cached in memory.
        GetFrame() does not need to block the calling thread. As with normal "ClientPull", buffers are unlikely
        to fill up, Server performance is unlikely to be affected. Latency is slightly reduced, but network
        traffic may increase if we request frames on behalf of the Client which are never used.

        The stream defaults to "ClientPull" mode as this is considered the safest option. If performance is a
        problem, then try "ClientPullPreFetch".  If latency, or missing frames are a problem, then use
        "ServerPush".

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.SetStreamMode( ViconDataStream.Client.StreamMode.EServerPush )
            >>> client.GetFrame()
            >>> client.SetStreamMode( ViconDataStream.Client.StreamMode.EClientPull )
            >>> client.GetFrame()

        \param  streamMode    The stream mode requested:
                                  + ClientPull
                                  + ClientPullPreFetch
                                  + ServerPush

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also : GetFrame, GetLatencyTotal
        """
        ret = self.client.SetStreamMode( {
            Client.StreamMode.EClientPull : CoreClient.ClientPull,
            Client.StreamMode.EClientPullPreFetch : CoreClient.ClientPullPreFetch,
            Client.StreamMode.EServerPush : CoreClient.ServerPush,
            }[ streamMode ] )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def GetFrame( self ):
        """Request a new frame to be fetched from the Vicon DataStream Server.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()

        \return True if a frame was available.
                False if the server is not currently streaming data.

        \throw A DataStreamException class containing the error:
                + NotConnected
                + NoFrame

        See Also : SetStreamMode
        """
        ret = self.client.GetFrame()

        if ret == CoreClient.NoFrame:
            return False

        if ret != CoreClient.Success:
            raise DataStreamException( ret )

        return True


    def GetFrameNumber( self ):
        """Return the number of the last frame retrieved from the DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetFrameNumber()
            361496

        \throw A DataStreamException class containing the error:
                + NotConnected
                + NoFrame

        See Also : GetFrame, GetTimecode
        """
        ret, value = self.client.GetFrameNumber()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return value

    def GetFrameRate(self):
        """Return the Vicon camera system frame rate (in Hz) at the time of the last frame retrieved from the DataStream.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetFrameRate()
            100.0

        \throw A DataStreamException class containing the error:
                + NotConnected
                + NoFrame

        See Also: GetFrame(), GetFrameNumber(), GetTimecode()
        """
        ret, value = self.client.GetFrameRate()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return value

    class TimecodeStandard( Enum ):
        ETimecodeStandardNone = 0
        EPAL = 1
        ENTSC = 2
        ENTSCDrop = 3
        EFilm = 4
        ENTSCFilm = 5
        EATSC = 6

    def GetTimecode(self):
        """Return the timecode information for the last frame retrieved from the DataStream.
        If the stream is valid but no timecode is available, the standard returned will be TimecodeStandardNone

        returns a tuple containing the following fields
        ( hours, minutes, seconds, frames, subframe, fieldFlag, standard, subFramesPerFrame, userBits )
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetTimecode()
            ( 1, 12, 24, 2, 0, 1, ENTSCFilm, 0, 8 )

        \throw A DataStreamException class containing the error:
                + NotConnected
                + NoFrame

        See Also: GetFrame(), GetFrameNumber()
        """
        ret, hours, minutes, seconds, frames, subframe, fieldFlag, standard, subFramesPerFrame, userBits = self.client.GetTimecode()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

        mappingDict = {
            CoreClient.TimecodeStandardNone : Client.TimecodeStandard.ETimecodeStandardNone,
            CoreClient.PAL : Client.TimecodeStandard.EPAL,
            CoreClient.NTSC : Client.TimecodeStandard.ENTSC,
            CoreClient.NTSCDrop : Client.TimecodeStandard.ENTSCDrop,
            CoreClient.Film : Client.TimecodeStandard.EFilm,
            CoreClient.NTSCFilm : Client.TimecodeStandard.ENTSCFilm,
            CoreClient.ATSC : Client.TimecodeStandard.EATSC

        }
        return hours, minutes, seconds, frames, subframe, fieldFlag, mappingDict[ standard ], subFramesPerFrame, userBits

    def GetLatencyTotal(self):
        """ Return the total latency in seconds introduced at various stages of the real-time pipeline. 
        If no latency information is available then all latencies will be reported as 0.0.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetLatencyTotal()
            0.0124434
        
        \throw A DataStreamException class containing the error:
                + NotConnected
                + NoFrame

        See Also: GetFrame(), GetTimecode(), GetLatencySamples()
        """
        ret, value = self.client.GetLatencyTotal()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return value

    def GetLatencySamples(self):
        """ Return a disctionary of component latency names and values representing various stages of the real-time pipeline.
        Values are reported in seconds 
        If no latency information is available then all latencies will be reported as 0.0.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetLatencySamples()
            { Processing, 0.0023 }
        
        \throw A DataStreamException class containing the error:
                + NotConnected
                + NoFrame

        See Also: GetFrame(), GetTimecode(), GetLatencySampleCount(), GetLatencySampleName(), GetLatencySampleValue()
        """
        latencySamples = {}
        ret, sampleCount = self.client.GetLatencySampleCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for sampleIndex in range( 0, sampleCount ):
            ret, sampleName = self.client.GetLatencySampleName( sampleIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            ret, sampleValue = self.client.GetLatencySampleValue( sampleName )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            latencySamples[ sampleName ] = sampleValue
        return latencySamples

    def GetHardwareFrameNumber(self):
        """Returns the hardware frame number as used by the cameras. This is not reset on synchronization.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetLatencySamples()

        \throw A DataStreamException class containing the error:
                + NotConnected
                + NoFrame

        See Also: GetFrameNumber()
        """
        ret, value = self.client.GetHardwareFrameNumber()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return value


    def GetFrameRates(self):
        """ Returns a dictionary of frame rate name/values reported by the application
        Frame rates are reported in Hz

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetFrameRates()
        
        \throw A DataStreamException class containing the error:
                + NotConnected
                + NoFrame

        See Also: GetFrameRateCount(), GetFrameRateValue()
        """
        frameRates = {}
        ret, frameRateCount = self.client.GetFrameRateCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for frameRateIndex in range( 0, frameRateCount ):
            ret, frameRateName = self.client.GetFrameRateName( frameRateIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            ret, frameRateValue = self.client.GetFrameRateValue( frameRateName )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            frameRates[ frameRateName ] = frameRateValue
        return frameRates

    def SetApexDeviceFeedback(self, deviceName, on):
        """ Enable haptic feedback for the selected Apex device.
        
        Apex device names may be obtained using GetDevices

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> devices = client.GetDevices()
            >>> client.SetApexDeviceFeedback( devices[0], True )

        \throw A DataStreamException class containing the error:
            + NotConnected
            + NoFrame
            + InvalidDeviceName
            + NullClient
            + HapticAlreadySet
        """
        ret = self.client.SetApexDeviceFeedback( deviceName, on )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    class AxisMapping( Enum ): 
        EUp = 0 
        EDown = 1
        ELeft = 2
        ERight = 3
        EForward = 4
        EBackward = 5

    def SetAxisMapping(self, xAxis, yAxis, zAxis):
        """ Remaps the 3D axis.

        Vicon Data uses a right-handed coordinate system, with +X forward, +Y left, and +Z up. 
        Other systems use different coordinate systems. The SDK can transform its data into any valid right-handed coordinate system by re-mapping each axis. 
        Valid directions are "Up", "Down", "Left", "Right", "Forward", and "Backward". Note that "Forward" means moving away from you, and "Backward" is moving towards you. 
        Common usages are
        Z-up: SetAxisMapping( Forward, Left, Up )
        Y-up: SetAxisMapping( Forward, Up, Right )

        This method can be called before connection

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.SetAxisMapping( ViconDataStream.Client.AxisMapping.EForward, ViconDataStream.Client.AxisMapping.ELeft, ViconDataStream.Client.AxisMapping.EUp )

        \throw A DataStreamException class containing the error:
               + CoLinearAxes
               + LeftHandedAxes
        See Also: GetAxisMapping()
        """
        mappingDict = {
            Client.AxisMapping.EUp : CoreClient.Up,
            Client.AxisMapping.EDown : CoreClient.Down,
            Client.AxisMapping.ELeft : CoreClient.Left,
            Client.AxisMapping.ERight : CoreClient.Right,
            Client.AxisMapping.EForward : CoreClient.Forward,
            Client.AxisMapping.EBackward : CoreClient.Backward }

        ret = self.client.SetAxisMapping( mappingDict[ xAxis ], mappingDict[ yAxis ], mappingDict[ zAxis ] )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def GetAxisMapping(self ):
        """ Get the current Axis mapping.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.GetAxisMapping()
            ( ViconDataStream.Client.AxisMapping.EForward, ViconDataStream.Client.AxisMapping.ELeft, ViconDataStream.Client.AxisMapping.EUp )

        See Also: SetAxisMapping()
        """
        xAxis, yAxis, zAxis = self.client.GetAxisMapping()

        mappingDict = {
            CoreClient.Up : Client.AxisMapping.EUp,
            CoreClient.Down : Client.AxisMapping.EDown,
            CoreClient.Left : Client.AxisMapping.ELeft,
            CoreClient.Right : Client.AxisMapping.ERight,
            CoreClient.Forward : Client.AxisMapping.EForward,
            CoreClient.Backward : Client.AxisMapping.EBackward}

        return ( mappingDict[ xAxis ], mappingDict[ yAxis ], mappingDict[ zAxis ] )

    class ServerOrientation( Enum ) : 
        EServerOrientationUnknown = 0
        EYUp = 1
        EZUp = 2

    def GetServerOrientation(self):
        """  Returns the internal data format of the datastream. Clients should use SetAxisMapping
        to control the output coordinate system rather than relying on this function.
        """
        ret, value = self.client.GetServerOrientation()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return { CoreClient.ServerOrientationUnknown : Client.ServerOrientation.EServerOrientationUnknown,
                 CoreClient.YUp : Client.ServerOrientation.EYUp,
                 CoreClient.ZUp : Client.ServerOrientation.EZUp }[ value ] 


    def SetTimingLog(self, clientLog, cgStreamLog):
        """  Sets a log file that timing debug information will be written to
        """
        ret = self.client.SetTimingLog( clientLog, cgStreamLog )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def ConfigureWireless(self):
        """ Request that the wireless adapters will be optimally configured for streaming data.
        
        On Windows this will disable background scan and enable streaming.
        The call does not need the client to be connected.
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.ConfigureWireless()

        \throw A DataStreamException class containing the error:
               + NotSupported if the OS does not support this function
               + WirelessConfigurationFailed if the request failed
             - The Error will provide additional information in the failure case

        """
        ret, error = self.client.ConfigureWireless()
        if ret != CoreClient.Success:
            raise DataStreamException( ret, additional=error )

    ##\name Subjects
    ## The following group of functions is concerned with obtaining subject data.
    ##
    ##\{

    ##\name Topology
    ## Functions related to subject and segment names and heirarchies.
    ##
    ##\{

    def GetSubjectNames( self ):
        """ Return a list of name for the subjects present in the datastream. This can be passed into segment and marker functions.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSubjectNames()
            [ "Colin", "Kim" ] 

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
        See Also: GetSubjectCount()
        """
        subjectNames = []
        ret, subjectCount = self.client.GetSubjectCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for subjectIndex in range( 0, subjectCount ):
            ret, subjectName = self.client.GetSubjectName( subjectIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            subjectNames.append( subjectName )
        return subjectNames

    def ClearSubjectFilter(self):
        """ Clear the subject filter. This will result in all subjects being sent.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.ClearSubjectFilter()
        
        See Also: AddToSubjectFilter()
        """
        ret = self.client.ClearSubjectFilter()
        if ret != CoreClient.Success:
            # Currently, this function will only return Success, so we don't expect this
            # to be thrown
            raise DataStreamException( ret )

    def AddToSubjectFilter(self, subjectName):
        """ Add a subject name to the subject filter.
        Only subjects present in the subject filter will be sent and
        subjects not in the filter will be presented as absent/occluded.

        If no filtered subjects are present, all subjects will be sent.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.AddToSubjectFilter( 'Colin' )
        
        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName

        See Also : ClearSubjectFilter()
        """
        ret = self.client.AddToSubjectFilter( subjectName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def GetSubjectRootSegmentName( self, subjectName ):
        """ Return the name of the root segment for a specified subject.

        This can be passed into segment functions.
        The root segment is the ancestor of all other segments in the subject.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> for subject in client.GetSubjects()
            >>>     client.GetSubjectRootSegmentName( subject )
            Hips

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName

        See Also: GetSegmentCount(), GetSegmentParentName(), GetSegmentChildCount(), GetSegmentChildName()
        """
        ret, name = self.client.GetSubjectRootSegmentName( subjectName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return name

    def GetSegmentNames(self, subjectName):
        """ Return a list containing the names of all segments for a specified subject in the DataStream.

        This information can be used in conjunction with GetSegmentName.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> for subject in client.GetSubjects()
            >>>     client.GetSegmentNames( subject )
            [ Hips, Spine, Head ]

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
        
        See Also: GetSubjectName(), GetSegmentName()
        """
        segmentNames = []
        ret, segmentCount = self.client.GetSegmentCount( subjectName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for segmentIndex in range( 0, segmentCount ):
            ret, segmentName = self.client.GetSegmentName( subjectName, segmentIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            segmentNames.append( segmentName )
        return segmentNames

    def GetSegmentChildren(self, subjectName, segmentName):
        """ Returns a list containing the names of all child segments for a specified subject segment.

        This can be passed into segment functions.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> for subject in client.GetSubjects()
            >>>     root = client.GetSubjectRootSegmentName( subject )
            >>>     client.GetSegmentChildren( subject, root )
            [ Spine ]

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
        
        See Also: GetSegmentNames()
        """
        childNames = []
        ret, childCount = self.client.GetSegmentChildCount( subjectName, segmentName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for childIndex in range( 0, childCount ):
            ret, childName = self.client.GetSegmentChildName( subjectName, segmentName, childIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            childNames.append( childName )
        return childNames

    def GetSegmentParentName(self, subjectName, segmentName):
        """ Return the name of the parent segment for a specified subject segment.

        If the specified segment is the root segment of the subject then it will return an empty string.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> for subject in client.GetSubjects()
            >>>     root = client.GetSubjectRootSegmentName( subject )
            >>>     client.GetSegmentParentName( subject, root )

            >>>     children = client.GetSegmentChildren( subject, root )
            >>>     for child in children:
            >>>         client.GetSegmentParentName( subject, child )
            Hips

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
        

        See Also: GetSegmentNames(), GetSegmentChildNames(), GetSubjectRootSegmentName()
        """
        ret, name = self.client.GetSegmentParentName( subjectName, segmentName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return name

    def GetObjectQuality(self, subjectName):
        """ Return the quality score for a specified Object (Subject).

        This is only implemented by applications that use an object tracking graph such as
        Evoke and Tracker.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> for subject in client.GetSubjects()
            >>>     client.GetObjectQuality( subject )
            0.4

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName

        See Also: GetSubjectCount(), GetSubjectName()
        """
        ret, quality = self.client.GetObjectQuality( subjectName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return quality

    ##\}

    ##\name Static pose
    ## Functions related to subject static pose.
    ##
    ##\{

    def GetSegmentStaticTranslation(self, subjectName, segmentName ):
        """ Return the static pose translation of a subject segment.
        
        The static translation of the segment corresponds to the PRE-POSITION element of the segment in the subject vsk. 
        It is the base setpoint of the segment, and is included in the value returned by GetLocalTranslation.
        If you are required to calculate the amount a segment has moved from its base setpoint, subtract this value from the local
        translation.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentStaticTranslation( 'Alice', 'Pelvis' )
            ( 0, 0, 0 )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
        
        See Also: GetSegmentStaticRotationHelical(), GetSegmentStaticRotationMatrix(), GetSegmentStaticRotationQuaternion(), 
        GetSegmentStaticRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """    
        a = CoreClient.doubleArray( 3 )
        ret = self.client.GetSegmentStaticTranslation( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return t

    def GetSegmentStaticRotationHelical(self, subjectName, segmentName):
        """ Return the static pose rotation of a subject segment in helical coordinates.
        The helical coordinates represent a vector whose length is the amount of rotation in radians, and the direction is the axis about which to rotate.
        
        The static rotation of the segment corresponds to the PRE-ORIENTATION element of the segment in the subject vsk. 
        It is the base rotation of the segment, and is included in the value returned by GetLocalRotation*.
        If you are required to calculate the amount a segment has rotated from its base setpoint, subtract this value from the local
        rotation.
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentStaticRotationHelical( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0 )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        See Also: GetSegmentStaticTranslation(), GetSegmentStaticRotationMatrix(), GetSegmentStaticRotationQuaternion(), 
        GetSegmentStaticRotationEulerXYZ(), GetSegmentLocalTranslation, GetSegmentLocalRotationHelical, GetSegmentLocalRotationMatrix, 
        GetSegmentLocalRotationQuaternion, GetSegmentLocalRotationEulerXYZ
        """
        a = CoreClient.doubleArray( 3 )
        ret = self.client.GetSegmentStaticRotationHelical( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return t

    def GetSegmentStaticRotationMatrix(self, subjectName, segmentName):
        """ Return the static pose rotation of a subject segment as a 3x3 row-major matrix.
        
        The static rotation of the segment corresponds to the PRE-ORIENTATION element of the segment in the subject vsk. 
        It is the base rotation of the segment, and is included in the value returned by GetLocalRotation*.
        If you are required to calculate the amount a segment has rotated from its base setpoint, subtract this value from the local
        rotation.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentStaticRotationMatrix( 'Alice', 'Pelvis' )
            (( 1.0, 0.0, 0.0 ), ( 0.0, 1.0, 0.0 ), ( 0.0, 0.0, 1.0 ))

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        
        See Also: GetSegmentStaticTranslation(), GetSegmentStaticRotationHelical(), GetSegmentStaticRotationQuaternion(), 
        GetSegmentStaticRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationQuaternion(), 
        GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 9 )
        ret = self.client.GetSegmentStaticRotationMatrix( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( ( a[0], a[1], a[2] ), ( a[3], a[4], a[5] ), ( a[6], a[7], a[8] ) )
        return t

    def GetSegmentStaticRotationQuaternion(self, subjectName, segmentName):
        """ Return the static pose rotation of a subject segment in quaternion coordinates.
        
        The quaternion is of the form (x, y, z, w) where w is the real component and x, y and z are the imaginary components. 
        N.B. This is different from that used in many other applications, which use (w, x, y, z).
        
        The static rotation of the segment corresponds to the PRE-ORIENTATION element of the segment in the subject vsk. 
        It is the base rotation of the segment, and is included in the value returned by GetLocalRotation*.
        If you are required to calculate the amount a segment has rotated from its base setpoint, subtract this value from the local
        rotation.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentStaticRotationQuaternion( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0, 1.0 )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        See Also: GetSegmentStaticTranslation(), GetSegmentStaticRotationHelical(), GetSegmentStaticRotationMatrix(), 
        GetSegmentStaticRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """ 
        a = CoreClient.doubleArray( 4 )
        ret = self.client.GetSegmentStaticRotationQuaternion( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2], a[3] )
        return t

    def GetSegmentStaticRotationEulerXYZ(self, subjectName, segmentName):
        """ Return the static pose rotation of a subject segment in Euler XYZ coordinates.
        
        The static rotation of the segment corresponds to the PRE-ORIENTATION element of the segment in the subject vsk. 
        It is the base rotation of the segment, and is included in the value returned by GetLocalRotation*.
        If you are required to calculate the amount a segment has rotated from its base setpoint, subtract this value from the local
        rotation.
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentStaticRotationEulerXYZ( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0  )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        See Also: GetSegmentStaticTranslation(), GetSegmentStaticRotationHelical(), GetSegmentStaticRotationMatrix(), 
        GetSegmentStaticRotationQuaternion(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), 
        GetSegmentLocalRotationMatrix(), GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ().
        """
        a = CoreClient.doubleArray( 3 )
        ret = self.client.GetSegmentStaticRotationEulerXYZ( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return t

    def GetSegmentStaticScale(self, subjectName, segmentName):
        """ Return a 3D Scale of a subject segment if present. 
        
        Not all applications support subject scale. If the application does not support scale data, an
        exception will be thrown with the error NotSupported.
        If the application supports scale data but none is available for the segment, an exception will be 
        thrown with the error NotPresent.
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentStaticScale( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0 )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               + NotSupported
               + NotPresent
        """
        a = CoreClient.doubleArray( 3 )
        ret = self.client.GetSegmentStaticScale( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return t


    ##\}

    ##\name Global pose
    ## Functions related to subject global pose.
    ##
    ##\{

    def GetSegmentGlobalTranslation( self, subjectName, segmentName ):
        """ Return the translation of a subject segment in global coordinates.

        The translation is of the form ( x, y, z ) where x, y and z are in millimeters with respect to the global origin.
        The function also returns whether the segment is occluded
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentGlobalTranslation( 'Alice', 'Pelvis' )
            (( 0.0, 0.0, 0.0 ), False )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        See Also: GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationMatrix(), GetSegmentGlobalRotationQuaternion(), 
        GetSegmentGlobalRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 3 )
        ret, o = self.client.GetSegmentGlobalTranslation( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( a[0], a[1], a[2] )
        return ( p, o )

    def GetSegmentGlobalRotationHelical( self, subjectName, segmentName ):
        """Return the rotation of a subject segment in global helical coordinates.
        
        The function also returns whether the segment is occluded
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentGlobalRotationHelical( 'Alice', 'Pelvis' )
            ( ( 0.0, 0.0, 0.0 ), False )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        
        See Also: GetSegmentGlobalTranslation(), GetSegmentGlobalRotationMatrix(), GetSegmentGlobalRotationQuaternion(), 
        GetSegmentGlobalRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 3 )
        ret, o = self.client.GetSegmentGlobalRotationHelical( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( a[0], a[1], a[2] )
        return ( p, o )

    def GetSegmentGlobalRotationQuaternion( self, subjectName, segmentName ):
        """ Return the rotation of a subject segment in global quaternion coordinates.
        
        The quaternion is of the form (x, y, z, w) where w is the real component and x, y and z are the imaginary components. 
        N.B. This is different from that used in many other applications, which use (w, x, y, z).
        
        The function also returns whether the segment is occluded
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentGlobalRotationQuaternion( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0, 1.0 ), False )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
         See Also: GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ(), 
         GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 4 )
        ret, o = self.client.GetSegmentGlobalRotationQuaternion( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( a[0], a[1], a[2], a[3] )
        return ( p, o )

    def GetSegmentGlobalRotationMatrix( self, subjectName, segmentName ):
        """ Return the rotation of a subject segment as a 3x3 row-major matrix in global coordinates.
        
        The function also returns whether the segment is occluded
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> client.GetSegmentGlobalRotationMatrix( 'Alice', 'Pelvis' )
            ((( 1.0, 0.0, 0.0 ), ( 0.0, 1.0, 0.0 ), ( 0.0, 0.0, 1.0 )), False )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
         See Also: GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ(), 
         GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 9 )
        ret, o = self.client.GetSegmentGlobalRotationMatrix( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( ( a[0], a[1], a[2] ),( a[3], a[4], a[5] ),( a[6], a[7], a[8] ) )
        return ( p, o )

    def GetSegmentGlobalRotationEulerXYZ( self, subjectName, segmentName ):
        """Return the rotation of a subject segment in global Euler XYZ coordinates.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableSegmentData()
            >>> client.GetFrame()
            >>> print( client.GetSegmentGlobalRotationEulerXYZ('Alice','Pelvis') )
            ((0.0, 0.0, 0.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName

        \return Tuple containing:
                - The rotation of the segment as a 3 touple (X,Y,Z).
                - Occluded will be True if the segment was absent at this frame. In this case the rotation will be [0,0,0].

        See Also : GetSegmentGlobalTranslation, GetSegmentGlobalRotationHelical...
        """
        a = CoreClient.doubleArray( 3 )
        ret, o = self.client.GetSegmentGlobalRotationEulerXYZ( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( a[0], a[1], a[2] )
        return ( p, o )

    ##\}

    ##\name Local pose
    ## Functions related to subject local pose.
    ##
    ##\{

    def GetSegmentLocalTranslation(self, subjectName, segmentName ):
        """ Return the translation of a subject segment in local coordinates relative to its parent segment.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableSegmentData()
            >>> client.GetFrame()
            >>> print( client.GetSegmentLocalTranslation('Alice','Pelvis') )
            ((0.0, 0.0, 0.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName

        See Also: GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), GetSegmentLocalRotationQuaternion(), 
        GetSegmentLocalRotationEulerXYZ(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationMatrix(), 
        GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """ 
        a = CoreClient.doubleArray( 3 )
        ret, occluded = self.client.GetSegmentLocalTranslation( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return ( t, occluded )

    def GetSegmentLocalRotationHelical(self, subjectName, segmentName ):
        """ Return the rotation of a subject segment in local helical coordinates relative to its parent segment.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableSegmentData()
            >>> client.GetFrame()
            >>> print( client.GetSegmentLocalRotationHelical('Alice','Pelvis') )
            ((0.0, 0.0, 0.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName
        
        See Also: GetSegmentLocalTranslation(), GetSegmentLocalRotationMatrix(), GetSegmentLocalRotationQuaternion(), 
        GetSegmentLocalRotationEulerXYZ(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), 
        GetSegmentGlobalRotationMatrix(), GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 3 )
        ret, occluded = self.client.GetSegmentLocalRotationHelical( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return ( t, occluded )

    def GetSegmentLocalRotationMatrix(self, subjectName, segmentName ):
        """ Return the rotation row-major matrix of a subject segment in local coordinates relative to its parent segment.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableSegmentData()
            >>> client.GetFrame()
            >>> print( client.GetSegmentLocalRotationMatrix('Alice','Pelvis') )
            (((1.0, 0.0, 0.0), 0.0, 1.0, 0.0), 0.0, 0.0, 1.0)), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName
        
        See Also: GetSegmentLocalTranslation(), GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationMatrix() , GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 9 )
        ret, occluded = self.client.GetSegmentLocalRotationMatrix( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( ( a[0], a[1], a[2] ),( a[3], a[4], a[5] ),( a[6], a[7], a[8] ) )
        return ( t, occluded )

    def GetSegmentLocalRotationQuaternion(self, subjectName, segmentName ):
        """ Return the rotation of a subject segment in local quaternion coordinates relative to its parent segment.
        The quaternion is of the form (x, y, z, w) where w is the real component and x, y and z are the imaginary components. 
        N.B. This is different from that used in many other applications, which use (w, x, y, z).
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableSegmentData()
            >>> client.GetFrame()
            >>> print( client.GetSegmentLocalRotationQuaternion('Alice','Pelvis') )
            ((0.0, 0.0, 0.0, 1.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName
        
        See Also: GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationEulerXYZ(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), 
        GetSegmentGlobalRotationMatrix(), GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 4 )
        ret, occluded = self.client.GetSegmentLocalRotationQuaternion( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2], a[3] )
        return ( t, occluded )

    def GetSegmentLocalRotationEulerXYZ(self, subjectName, segmentName ):
        """ Return the rotation of a subject segment in local Euler XYZ coordinates relative to its parent segment.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableSegmentData()
            >>> client.GetFrame()
            >>> print( client.GetSegmentLocalRotationEulerXYZ('Alice','Pelvis') )
            ((0.0, 0.0, 0.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName
        
        See Also: GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), GetSegmentLocalRotationQuaternion(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationMatrix() , GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 3 )
        ret, occluded = self.client.GetSegmentLocalRotationEulerXYZ( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return ( t, occluded )

    ##\}
    ##\}

    ##\name Labeled Markers
    ##\{

    def GetMarkerNames(self, subjectName):
        """ Return the a list of labeled marker names for a specified subject in the DataStream along with their parent segment name.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableMarkerData()
            >>> client.GetFrame()
            >>> client.GetMarkerNames( 'Obj' )
            [ ( 'Obj001', 'Root' ), ('Obj002', 'Root' ), ('Obj003', 'Root' ), ('Obj004', 'Root' ) ]

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName

        See Also: GetSubjectName(), GetMarkerGlobalTranslation()
        """ 
        markers = []

        ret, count = self.client.GetMarkerCount( subjectName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for markerIndex in range( 0, count ):
            ret, name = self.client.GetMarkerName( subjectName, markerIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            ret, parentSegment = self.client.GetMarkerParentName( subjectName, name )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )

            markers.append( ( name, parentSegment ) ) 
        return markers

    def GetMarkerGlobalTranslation(self, subjectName, markerName ):
        """ Return the translation of a subject marker in global coordinates.
        
        The Translation is of the form ( x, y, z ) where x, y and z are in millimeters with respect to the global origin.
        The function also returns whether the marker is occluded
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableMarkerData()
            >>> client.GetFrame()
            >>> client.GetMarkerGlobalTranslation( 'Obj','Obj001')
            ( ( 0.0, 0.0, 0.0 ), False )

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidMarkerName
                
        See Also: GetMarkerName()
        """ 
        a = CoreClient.doubleArray( 3 )
        ret, occluded = self.client.GetMarkerGlobalTranslation( subjectName, markerName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return ( t, occluded )

    def GetMarkerRayAssignments(self, subjectName, markerName):
        """ Return the camera IDs for the indexed rays that are contributing to a labeled marker in the DataStream. 
    
        This function returns a list of tuples that contain a camera id and the index of the centroid on the 
        camera originating the ray
        
        >>> import ViconDataStream
        >>> client = ViconDataStream.Client()
        >>> client.Connect('localhost')
            >>> client.EnableMarkerRayData()
        >>> client.GetFrame()
        >>> ray_assignments = client.GetMarkerRayAssignments( 'Obj','Obj001')
        >>> for ray in ray_assignments:
        >>>     print ray
        ( 2, 1 )

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidMarkerName
                
        See Also: EnableMarkerRayData(), DisableMarkerRayData(), IsMarkerRayDataEnabled()
        """
        centroidAssignments = []
        ret, count = self.client.GetMarkerRayAssignmentCount( subjectName, markerName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for rayIndex in range( 0, count ):
            ret, cameraId, centroidIndex = self.client.GetMarkerRayAssignment( subjectName, markerName, rayIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            centroidAssignments.append( ( cameraId, centroidIndex ) )
        return centroidAssignments

    def GetLabeledMarkers(self):
        """ Returns a list of all labeled markers in the datastream across all subjects. 
        
        The list contains tuples of the marker setpoint, in the form ( x, y, z ) where x, y and z are in millimeters with respect to the global origin.
        and the trajectory ID of the marker
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableMarkerData()
            >>> client.GetFrame()
            >>> labeled_markers = client.GetLabeledMarkers()
            >>> for marker in labeled_markers
            >>>     print marker
            (( 0.0, 0.0, 0.0 ), 4 )

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                
        See Also: GetLabeledMarkerGlobalTranslation()
        """
        labeledMarkers = []
        ret, count = self.client.GetLabeledMarkerCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for markerIndex in range( 0, count ):
            a = CoreClient.doubleArray( 3 )
            ret, trajID = self.client.GetLabeledMarkerGlobalTranslation( markerIndex, a )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            labeledMarkers.append( ( ( a[0], a[1], a[2] ), trajID ) )
        return labeledMarkers

    ##\}

    ##\name Unlabeled Markers
    ##\{

    def GetUnlabeledMarkers(self):
        """ Returns a list of all unlabeled markers in the datastream across all subjects. 
        
        The list contains tuples of the marker setpoint, in the form ( x, y, z ) where x, y and z are in millimeters with respect to the global origin.
        and the trajectory ID of the marker
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableUnlabeledMarkerData()
            >>> client.GetFrame()
            >>> unlabeled_markers = client.GetUnlabeledMarkers()
            >>> for marker in unlabeled_markers
            >>>     print marker
            (( 0.0, 0.0, 0.0 ), 4 )

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                
        See Also: GetLabeledMarkerGlobalTranslation()
        """
        unlabeledMarkers = []
        ret, count = self.client.GetUnlabeledMarkerCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for markerIndex in range( 0, count ):
            a = CoreClient.doubleArray( 3 )
            ret, trajID = self.client.GetUnlabeledMarkerGlobalTranslation( markerIndex, a )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            unlabeledMarkers.append( ( ( a[0], a[1], a[2] ), trajID ) )
        return unlabeledMarkers

    ##\}

    ##\name Devices
    ##\{

    class DeviceType( Enum ) : 
        EUnknownDevice = 0
        EForceplate = 1
        EEyeTracker = 2

    def GetDeviceNames(self):
        """ Return the names of all force plates, EMGs, and other devices in the DataStream.

        This returns a list of tuples, containing the name and type of the device

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetDeviceNames()
            [('Unnamed Device 1', ViconDataStream.Client.DeviceType.EUnknownDevice )]  

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                        
        See Also: GetDeviceName()
        """
        deviceNames = []
        ret, count = self.client.GetDeviceCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for deviceIndex in range( 0, count ):
            ret, deviceName, deviceType = self.client.GetDeviceName( deviceIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            mappedDeviceType = {
                CoreClient.DeviceTypeUnknown : Client.DeviceType.EUnknownDevice,
                CoreClient.ForcePlate : Client.DeviceType.EForceplate,
                CoreClient.EyeTracker : Client.DeviceType.EEyeTracker
            }[ deviceType ]
            deviceNames.append( ( deviceName, mappedDeviceType ) )
        return deviceNames

    class Unit( Enum ) : 
        EUnitUnknown = 0
        EVolt = 1
        ENewton = 2
        ENewtonMeter = 3
        EMeter = 4
        EKilogram = 5
        ESecond = 6
        EAmpere = 7
        EKelvin = 8
        EMole = 9
        ECandela = 10
        ESteradian = 11
        EMeterSquared = 12
        EMeterCubed = 13
        EMeterPerSecond = 14
        EMeterPerSecondSquared = 15
        ERadianPerSecond = 16
        ERadianPerSecondSquared = 17
        EHertz = 18
        EJoule = 19
        EWatt = 20
        EPascal = 21
        ELumen = 22
        ELux = 23
        ECoulomb = 24
        EOhm = 25
        EFarad = 26
        EWeber = 27
        ETesla = 28
        EHenry = 29
        ESiemens = 30
        EBecquerel = 31
        EGray = 32
        ESievert = 33
        EKatal = 34

    def GetDeviceOutputDetails(self, deviceName):
        """ Returns a list of device outputs for the specified device.

        Each output is represented by a tuple containing the name of the output, the component and the SI unit.
        These names are used with GetDeviceOutputValues() to obtain the values

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetDeviceOutputDetails( 'Unnamed Device 1' )
            [('Velocity', '1', ViconDataStream.Client.Unit.EMeterPerSecond), ('Velocity', '2', ViconDataStream.Client.Unit.EMeterPerSecond)]

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidDeviceName
                        
        See Also: GetDeviceName(), GetDeviceOutputValues()
        """
        deviceOutputDetails = []
        ret, deviceOutputCount = self.client.GetDeviceOutputCount( deviceName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for deviceOutputIndex in range( 0, deviceOutputCount ):
            dummyArg = 'arg'
            ret, outputName, componentName, componentUnit = self.client.GetDeviceOutputNameComponent( deviceName, deviceOutputIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            mappedComponentUnit = {
                CoreClient.UnitUnknown : Client.Unit.EUnitUnknown,
                CoreClient.Volt : Client.Unit.EVolt,
                CoreClient.Newton : Client.Unit.ENewton,
                CoreClient.NewtonMeter : Client.Unit.ENewtonMeter,
                CoreClient.Meter : Client.Unit.EMeter,
                CoreClient.Kilogram : Client.Unit.EKilogram,
                CoreClient.Second : Client.Unit.ESecond,
                CoreClient.Ampere : Client.Unit.EAmpere,
                CoreClient.Kelvin : Client.Unit.EKelvin,
                CoreClient.Mole : Client.Unit.EMole,
                CoreClient.Candela : Client.Unit.ECandela,
                CoreClient.Steradian : Client.Unit.ESteradian,
                CoreClient.MeterSquared : Client.Unit.EMeterSquared,
                CoreClient.MeterCubed : Client.Unit.EMeterCubed,
                CoreClient.MeterPerSecond : Client.Unit.EMeterPerSecond,
                CoreClient.MeterPerSecondSquared : Client.Unit.EMeterPerSecondSquared,
                CoreClient.RadianPerSecond : Client.Unit.ERadianPerSecond,
                CoreClient.RadianPerSecondSquared : Client.Unit.ERadianPerSecondSquared,
                CoreClient.Hertz : Client.Unit.EHertz,
                CoreClient.Joule : Client.Unit.EJoule,
                CoreClient.Watt : Client.Unit.EWatt,
                CoreClient.Pascal : Client.Unit.EPascal,
                CoreClient.Lumen : Client.Unit.ELumen,
                CoreClient.Lux : Client.Unit.ELux,
                CoreClient.Coulomb : Client.Unit.ECoulomb,
                CoreClient.Ohm : Client.Unit.EOhm,
                CoreClient.Farad : Client.Unit.EFarad,
                CoreClient.Weber : Client.Unit.EWeber,
                CoreClient.Tesla : Client.Unit.ETesla,
                CoreClient.Henry : Client.Unit.EHenry,
                CoreClient.Siemens : Client.Unit.ESiemens,
                CoreClient.Becquerel : Client.Unit.EBecquerel,
                CoreClient.Gray : Client.Unit.EGray,
                CoreClient.Sievert : Client.Unit.ESievert,
                CoreClient.Katal : Client.Unit.EKatal
            }[ componentUnit ]
            deviceOutputDetails.append( ( outputName, componentName, mappedComponentUnit ) )
        return deviceOutputDetails

    def GetDeviceOutputValues(self, deviceName, deviceOutputName, deviceComponentName ):
        """ Returns the output values for a specied device output component.

        Returns a tuple containing a list of individual subsample values for the frame
        If an analog device is sampling at 1000 Hz and the system is running at 100 Hz then the list would contain 10 subsamples.

        The force plate data provided in the individual device channels is in a coordinate system
        local to the force plate aligned Z upwards, Y towards the front of the force plate. 
        This coordinate system is located at the center of the top surface of the force plate.
        Any plate origin offset has been accounted for in the moment data. These are forces not reactions.

        The second component of the tuple contains an occluded flag.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetDeviceOutputValues( 'Unnamed Device 1', 'Velocity', '1' )
            ([-1.25, -1.25, -1.25, -1.25, -1.25, -1.25, -1.25, -1.25, -1.25, -1.25], False)         

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidDeviceName
                + InvalidDeviceOutputName
                + InvalidDeviceComponentName
                        
        See Also: GetDeviceName(), GetDeviceOutputDetails()
        """
        subsampleValues = []
        ret, numSubsamples, occluded = self.client.GetDeviceOutputSubsamples( deviceName, deviceOutputName, deviceComponentName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for subsampleIndex in range( 0, numSubsamples ):
            ret, value, occluded = self.client.GetDeviceOutputValue( deviceName, deviceOutputName, deviceComponentName, subsampleIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            subsampleValues.append( value )
        return subsampleValues, occluded

    def GetForcePlates(self):
        """ Return the force plates available in the DataStream.

        This function returns a list of force plate IDs, that may be used with the other referenced
        functions

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetForcePlates()
            [1]         

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame

        See Also: GetGlobalMomentVector(), GetGlobalMomentVector(), GetGlobalCentreOfPressure()
        """
        plateIDs = []
        ret, count = self.client.GetForcePlateCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for plateIndex in range( 0, count ):
            ret, plateID = self.client.GetForcePlateID( plateIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            plateIDs.append( plateID )
        return plateIDs

    def GetGlobalForceVector(self, plateID ):
        """ Return the force vector for the force plate in global coordinates.

        The vector is in Newtons and is with respect to the global coordinate system regardless of the orientation of the force plate.
        The vector represents the force exerted upon the force plate, not the reaction force.

        This function returns a list containing all subsamples in the frame.

        See Also: GetGlobalMomentVector(), GetGlobalCentreOfPressure()

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetGlobalForceVector( 1 )
            [(42.284639427332785, 97.55907243300906, -731.4132690429688)]

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidIndex
        """
        samples = []
        ret, subsamples = self.client.GetForcePlateSubsamples( plateID )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for sampleIndex in range( 0, subsamples ):
            v = CoreClient.doubleArray( 3 )
            ret = self.client.GetGlobalForceVectorAtSample( plateID, sampleIndex, v )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            samples.append( ( v[0], v[1], v[2] ) )
        return samples

    def GetGlobalMomentVector(self, plateID ):
        """ Return the moment vector for the force plate in global coordinates.

        The vector is in Newton-meters and is with respect to the global coordinate system regardless of the orientation of the force plate.
        The vector represents the moment exerted upon the force plate, not the reaction moment. Any force plate origin offset is accounted
        for in the moments so they are acting about the exact center of the top surface of the force plate.

        This function returns a list containing all subsamples in the frame.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetGlobalMomentVector( 1 )
            [(45.75836106860459, 11.502136470533424, 9.913260459899902)]

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidIndex

        See Also: GetGlobalForceVector(), GetGlobalCentreOfPressure()
        """
        samples = []
        ret, subsamples = self.client.GetForcePlateSubsamples( plateID )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for sampleIndex in range( 0, subsamples ):
            v = CoreClient.doubleArray( 3 )
            ret = self.client.GetGlobalMomentVectorAtSample( plateID, sampleIndex, v )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            samples.append( ( v[0], v[1], v[2] ) )
        return samples

    def GetGlobalCenterOfPressure(self, plateID ):
        """ Return the center of pressure for the force plate in global coordinates.

        The setpoint is in millimeters and is with respect to the global coordinate system.
        This function returns a list containing all subsamples in the frame.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetGlobalCenterOfPressure( 1 )
            [(0.2628258969981016, 0.184538420270171, 0.0)]

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidIndex
        
        See Also: GetGlobalForceVector(), GetGlobalMomentVector()
        """
        samples = []
        ret, subsamples = self.client.GetForcePlateSubsamples( plateID )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for sampleIndex in range( 0, subsamples ):
            v = CoreClient.doubleArray( 3 )
            ret = self.client.GetGlobalCentreOfPressureAtSample( plateID, sampleIndex, v )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            samples.append( ( v[0], v[1], v[2] ) )
        return samples

    def GetEyeTrackers(self ):
        """ Return a list containing the ids of eye trackers available in the DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetEyeTrackers()
            [1]

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidIndex

        See Also: GetEyeTrackerGlobalPosition(), GetEyeTrackerGlobalGazeVector()
        """
        eyeTrackerIDs = []
        ret, eyeTrackerCount = self.client.GetEyeTrackerCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for eyeTrackerIndex in range( 0, eyeTrackerCount ):
            ret, eyeTrackerID = self.client.GetEyeTrackerID( eyeTrackerIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            eyeTrackerIDs.append( eyeTrackerID )
        return eyeTrackerIDs

    def GetEyeTrackerGlobalPosition(self, eyeTrackerID ):
        """ Return the location of the eye. The setpoint is in millimeters with respect to the global origin.

        The function returns the location of the eye and an occluded flag.
        The segment and device data need to be enabled to get the setpoint.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableSegmentData()
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetEyeTrackerGlobalPosition( 1 )
            ((115.64559595431018, -277.24351947721726, 1649.4266941468152), False)

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidIndex

        See Also: GetEyeTrackerCount(), GetEyeTrackerGlobalGazeVector()
        """
        v = CoreClient.doubleArray( 3 )
        ret, occluded = self.client.GetEyeTrackerGlobalPosition( eyeTrackerID, v )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return ( ( v[0], v[1], v[2] ), occluded )

    def GetEyeTrackerGlobalGazeVector(self, eyeTrackerID):
        """ Return the gaze direction as a unit vector in global coordinates.

        The gaze vector will be marked as occluded if the segment that has the eye tracker attached is not visible,
        the eye tracker is not calibrated or the pupil is not found.

        The function returns the gaze vector of the eye and an occluded flag.

        The segment and device data need to be enabled to get the gaze vector.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableSegmentData()
            >>> client.EnableDeviceData()
            >>> client.GetFrame()
            >>> client.GetEyeTrackerGlobalPosition( 1 )
            ((0.11004106225075291, -0.9889295867465293, 0.09954548169573053), False)

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidIndex

        See Also: GetEyeTrackerCount(), GetEyeTrackerGlobalPosition()
        """
        v = CoreClient.doubleArray( 3 )
        ret, occluded = self.client.GetEyeTrackerGlobalGazeVector( eyeTrackerID, v )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return ( ( v[0], v[1], v[2] ), occluded )

    ##\}

    ##\name Cameras
    ##\{

    def GetCameraNames(self):
        """ Returns a list of the names of cameras available in the DataStream.

        These names can be passed in the remaining functions requiring camera name
        as a parameter

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableCentroidData()
            >>> client.GetFrame()
            >>> client.GetCameraNames()
            ['Vantage 16 (2105980)', 'Vantage 8 (2106132)', 'Vantage 16 (2106427)']

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame

        See Also: GetCentroidCount(), GetCentroidPosition()
        """
        cameraNames = []
        ret, count = self.client.GetCameraCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for cameraIndex in range( 0, count ):
            ret, name = self.client.GetCameraName( cameraIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            cameraNames.append( name )
        return cameraNames

    def GetCameraID(self, cameraName):
        """ Returns the internal ID of the camera with the specified name.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableCentroidData()
            >>> client.GetFrame()
            >>> client.GetCameraID( 'Vantage 16 (2105980)' )
            2105980

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidCameraName

        See Also: GetCameraNames()
        """
        ret, id = self.client.GetCameraID( cameraName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return id

    def GetCameraUserID(self, cameraName):
        """ Returns the user-assigned ID of the camera with the specified name.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableCentroidData()
            >>> client.GetFrame()
            >>> client.GetCameraUserID( 'Vantage 16 (2105980)' )
            24

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidCameraName

        See Also: GetCameraNames()
        """
        ret, id = self.client.GetCameraUserID( cameraName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return id

    def GetCameraType(self, cameraName):
        """ Returns the type of the camera with the specified name. 
            The type returned is an internal type string.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableCentroidData()
            >>> client.GetFrame()
            >>> client.GetCameraType( 'Vantage 16 (2105980)' )
            'Vantage 16'

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidCameraName

        See Also: GetCameraNames()
        """
        ret, type = self.client.GetCameraType( cameraName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return type

    def GetCameraDisplayName(self, cameraName ):
        """ Returns the name of of the camera type as a string suitable for display to a user.


            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableCentroidData()
            >>> client.GetFrame()
            >>> client.GetCameraDisplayName( 'Vantage 16 (2105980)' )
            'Vantage 16'

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidCameraName
        """
        ret, name = self.client.GetCameraDisplayName( cameraName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return name

    def GetCameraResolution(self, cameraName):
        """ Returns the sensor resolution of the camera with the specified name.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableCentroidData()
            >>> client.GetFrame()
            >>> client.GetCameraResolution( 'Vantage 16 (2105980)' )
            (4096, 4096 )

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidCameraName
        """
        ret, resX, resY = self.client.GetCameraResolution( cameraName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return ( resX, resY )

    def GetIsVideoCamera(self, cameraName):
        """ Returns whether the camera with the specified name is a video camera.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableCentroidData()
            >>> client.GetFrame()
            >>> client.GetIsVideoCamera( 'Vantage 16 (2105980)' )
            False

        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidCameraName
        """
        ret, isVideo = self.client.GetIsVideoCamera( cameraName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return isVideo

    def GetCentroids(self, cameraName):
        """ Returns a list containing the setpoint, radius and weight of the centroids reported by a named camera

            If weight is not present, it will be set to None

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.EnableCentroidData()
            >>> client.GetFrame()
            >>> centroids = client.GetCentroids( 'Vantage 16 (2105980)' )
            >>> for centroid in centroids:
                    print centroid
            ((1851.8839111328125, 3799.03173828125), 10.114079475402832, 1.0)
            ((1799.185791015625, 3848.348388671875), 10.19340991973877, 1.0)
            ...
        \throw A DataStreamException class containing the error:

                + NotConnected
                + Success
                + NoFrame
                + InvalidCameraName
        """
        centroidData = []
        ret, centroidCount = self.client.GetCentroidCount( cameraName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for centroidIndex in range( 0, centroidCount ):
            position = CoreClient.doubleArray( 2 )
            ret, radius = self.client.GetCentroidPosition( cameraName, centroidIndex, position )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            ret, weight = self.client.GetCentroidWeight( cameraName, centroidIndex )
            if ret != CoreClient.Success:
                weight = None
            centroidData.append( ( ( position[0], position[1] ), radius, weight ) )
        return centroidData

    # Methods to access greyscale blobs and video frames have been ommitted as they are unsuitable for inclusion in their current form.

    ##\}


class RetimingClient:
    """ Vicon DataStream SDK retiming client.`

      ===========================
      Intended uses
      -------------
      The Vicon DataStream re-timing client provides calls to obtain subject data from the 
      DataStream with minimal latency and temporal jitter. 
      When UpdateFrame() is called, the client uses re-timed data that has been linearly interpolated 
      from an internal buffer to predict the setpoint of each segment to the current time.
    
      The system and network latencies are used when determining the amount of prediction required.
      If additional prediction is required, for example, for use in a VR system where an additional latency 
      is present due to rendering and display latency; this may be requested in the call to UpdateFrame().
    
      The user will call UpdateFrame(), which will update the current frame state to 
      the time of calling and return immediately. This is intended for use in systems where you require
      subject data positions at times driven by an external clock.
    
      If you do not have an external clock, and require behavior similar to that of the standard DataStream 
      client running in ServerPush streaming mode, then the system may be configured to provide frame data
      at a consistent frame rate by providing a frame rate to the Connect() call. The user will then call 
      WaitForFrame(), which will block in a similar method to Client::GetFrame(), but using retimed data
      in order to keep the frame period very consistent.
     
      Examples of use
      --------------
     
      If you are using the client in a situation where you need to obtain the setpoint of subjects
     
           client = ViconDataStream.RetimingClient()
           client.Connect( "localhost" )

           def render_callback( client ): 
           
              client.UpdateFrame();
              subjects = client.GetSubjects():
              for subject in subjects:
                segments = client.GetSegments( subject )
                for segment in segments:
                    rotation, occluded = client.GetSegmentGlobalRotationQuaternion( subject, segment )
                    
    
     If using the client where there is no render call and you require your own timing.
     
           client = ViconDataStream.RetimingClient()
       
           # Request a retimed update frame rate of 90Hz.
           client.Connect( "localhost", 90 )
           while( _MyClient.IsConnected() ):
           
             client.WaitForFrame()
              # iterate over subjects and segments and obtain the joint positions and rotations as above.

    """
    def __init__( self ):
        """The Constructor.

        Instances of the Vicon Data Stream RetimingClient create a DataStreamClient internally that manages the connection 
        to the data stream.
        
        The RetimingClient will set up the underlying client to receive the required data from the stream and to set the 
        correct data delivery mode, so it is not necessary to set this up manually.

        You can create many instances of the Vicon DataStream Client which can connect to multiple Vicon DataStream Servers.

        The Client is implicitly destroyed as it goes out of scope.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
        """
        
        self.client = CoreClient.VClient()
        self.retimer = CoreClient.VRetimingClient( self.client )

    def GetVersion( self ):
      """ Get the version of the client SDK in use.

          >>> import ViconDataStream
          >>> client = ViconDataStream.Client()
          >>> client.GetVersion()
          (1, 10, 0)

      \return A tuple (Major, Minor, Point).

      Note: This is not the version of the server application.
      """
      v = self.client.GetVersion()
      return ( v[0], v[1], v[2] )

    def Connect( self, hostname, frame_rate = 0.0 ):
        """ Establish a dedicated connection to a Vicon DataStream Server.

        See Also : ConnectToMulticast, Disconnect, IsConnected.

        The function defaults to connecting on port 801.
        You can specify an alternate port number after a colon.
        Current Vicon products serve data on ports 801 and 804.
        804 is only supported by some products and provides a live only low-latency stream
        801 is supported by all products and works with both live and offline data.

        If a frame rate is supplied, the retiming clients internal frame output clock will
        be started. For usage, see the class documentation

        Segment data is automatically enabled when connecting. 

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.Connect( "localhost" )

        \param  HostName The DNS identifiable name, or IP address of the PC hosting the DataStream server.
                         For example:
                         + "localhost"
                         + "MyViconPC:801"
                         + "10.0.0.2"

        The function will throw DataStreamException if there is a problem:
                + InvalidHostName
                + ClientAlreadyConnected
                + ClientConnectionFailed
        """
        internal = self.client.NewClient()
        ret = self.retimer.Connect( internal, hostname, self.client.IsLightweightSegmentDataEnabled() )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        if frame_rate > 0:
            self.retimer.StartOutput( frame_rate )

    def IsConnected( self ):
        """ Is the client connected to the server?

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.IsConnected()
             False
             >>> client.Connect("localhost")
             >>> client.IsConnected()
             True

        \return *True* if the connection to the server is live, *False* otherwise.

        See Also : Connect, Disconnect
        """
        return self.client.IsConnected()

    def Disconnect( self ):
        """ Breaks the connection with the server application.

             >>> import ViconDataStream
             >>> client = ViconDataStream.Client()
             >>> client.Connect("localhost")
             >>> client.IsConnected()
             True
             >>> client.Disconnect()
             >>> client.IsConnected()
             False

        \throw DataStreamException if the client is not connected.
        """
        ret = self.retimer.Disconnect()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def EnableLightweightSegmentData(self):
        """ Enable a lightweight transmission protocol for kinematic segment data in the Vicon DataStream. 

        This will reduce the network bandwidth required to transmit segment data to approximately a quarter of that required by the 
        previous method, at the expense of a small amount of precision.
        Use the existing methods such as GetSegmentGlobalTranslation() and GetSegmentGlobalRotationMatrix() as usual to obtain the segment data.
  
    
        Call this function on startup, after connecting to the server, and before trying to read local or global segment data.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect("localhost")
            >>> client.EnableLightweightSegmentData()
            >>> client.UpdateFrame()
            >>> client.GetSegmentGlobalTranslation("Alice","Root")
            ((-522.2945270748643, -1.56943597526001, 1119.1174983031265), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
        """
        ret = self.client.EnableLightweightSegmentData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def DisableLightweightSegmentData(self):
        """ Disable the lightweight output mode for kinematic segment data in the Vicon DataStream.
        This call automatically re-enables normal segment data. This is different to the normal client
        where the user must do this themselves. This is so that segment data is always enabled in the
        retiming client.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect("localhost")
            >>> client.DisableLightweightSegmentData() 

        \throw A DataStreamException class containing the error:
                + NotConnected

        See Also: EnableLightweightSegmentData, IsLightweightSegmentDataEnabled()
        """
        ret = self.client.DisableLightweightSegmentData()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def IsLightweightSegmentDataEnabled(self):
        """ Return whether the lightweight transport mode for kinematic segment data is enabled in the Vicon DataStream.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect("localhost")
            >>> if client.IsLightweightSegmentDataEnabled() is True:
            >>>     print( "Lightweight Segment Data Enabled" )
        
        
        See Also: EnableSegmentData(), DisableSegmentData(), IsMarkerDataEnabled(), IsUnlabeledMarkerDataEnabled(), IsDeviceDataEnabled()
        """
        return self.client.IsLightweightSegmentDataEnabled()

    def SetAxisMapping(self, xAxis, yAxis, zAxis):
        """ Remaps the 3D axis.

        Vicon Data uses a right-handed coordinate system, with +X forward, +Y left, and +Z up. 
        Other systems use different coordinate systems. The SDK can transform its data into any valid right-handed coordinate system by re-mapping each axis. 
        Valid directions are "Up", "Down", "Left", "Right", "Forward", and "Backward". Note that "Forward" means moving away from you, and "Backward" is moving towards you. 
        Common usages are
        Z-up: SetAxisMapping( Forward, Left, Up )
        Y-up: SetAxisMapping( Forward, Up, Right )

        This method can be called before connection

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.SetAxisMapping( ViconDataStream.Client.AxisMapping.EForward, ViconDataStream.Client.AxisMapping.ELeft, ViconDataStream.Client.AxisMapping.EUp )

        \throw A DataStreamException class containing the error:
               + CoLinearAxes
               + LeftHandedAxes
        See Also: GetAxisMapping()
        """
        mappingDict = {
            Client.AxisMapping.EUp : CoreClient.Up,
            Client.AxisMapping.EDown : CoreClient.Down,
            Client.AxisMapping.ELeft : CoreClient.Left,
            Client.AxisMapping.ERight : CoreClient.Right,
            Client.AxisMapping.EForward : CoreClient.Forward,
            Client.AxisMapping.EBackward : CoreClient.Backward }

        ret = self.client.SetAxisMapping( mappingDict[ xAxis ], mappingDict[ yAxis ], mappingDict[ zAxis ] )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def GetAxisMapping(self ):
        """ Get the current Axis mapping.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.GetAxisMapping()
            ( ViconDataStream.Client.AxisMapping.EForward, ViconDataStream.Client.AxisMapping.ELeft, ViconDataStream.Client.AxisMapping.EUp )

        See Also: SetAxisMapping()
        """
        xAxis, yAxis, zAxis = self.client.GetAxisMapping()

        mappingDict = {
            CoreClient.Up : Client.AxisMapping.EUp,
            CoreClient.Down : Client.AxisMapping.EDown,
            CoreClient.Left : Client.AxisMapping.ELeft,
            CoreClient.Right : Client.AxisMapping.ERight,
            CoreClient.Forward : Client.AxisMapping.EForward,
            CoreClient.Backward : Client.AxisMapping.EBackward}

        return ( mappingDict[ xAxis ], mappingDict[ yAxis ], mappingDict[ zAxis ] )

    def UpdateFrame( self, offset = 0.0 ):
        """ Update the current frame state to represent the setpoint of all active subjects at the current time.
        
        The setpoint of each segment is estimated by predicting forwards from the most recent
        frames received from the DataStream, taking into account the latency reported by the 
        system to determine the amount of prediction required.
        
        The results of calls which return details about the current frame state such as GetSubjectCount() 
        and GetSegmentGlobalRotationQuaternion() will all return the stream contents and setpoint at the
        time that this call was made. 
        
        If no call to UpdateFrame() is made, calls querying the stream state will return NoFrame.

        An additional offset may be provided that will be applied to the time at which the predicted
        setpoint is calculated. This may be used to compensate for additional delays that
        are in the user's system, such as render delay. 

        See Also: SetMaximumPrediction()

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect( 'locahost' )
            >>> client.UpdateFrame()

        \throw A DataStreamException class containing the error:
               + InvalidOperation - The client is running the internal frame timer. Use WaitForFrame instead
               + NoData - Not enough data has been received to produce a result
               + Invalid - An internal error has occurred
               + Early - The frame time requested is too early to predict
               + Late - The frame time requested is too late to predict

        """
        ret = self.retimer.UpdateFrame( offset )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def WaitForFrame( self ):
        """ Used when running the retiming client with a specified frame rate. This call will
        block until the next frame is available, as driven by an internal clock running at
        the frame rate specified by Connect( Host, FrameRate). The frame data is re-timed to the
        correct time point. This call is equivalent to GetFrame() in the non retiming client.


            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect( 'locahost' )
            >>> while( client.WaitForFrame() ):
            >>>     # Get segment data here

        \throw A DataStreamException class containing the error:
               + NoFrame - The internal frame timer is not running

        """
        ret = self.retimer.WaitForFrame()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def GetSubjectNames( self ):
        """ Return a list of name for the subjects present in the datastream. This can be passed into segment and marker functions.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSubjectNames()
            [ "Colin", "Kim" ] 

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
        See Also: GetSubjectCount()
        """
        subjectNames = []
        ret, subjectCount = self.retimer.GetSubjectCount()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for subjectIndex in range( 0, subjectCount ):
            ret, subjectName = self.retimer.GetSubjectName( subjectIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            subjectNames.append( subjectName )
        return subjectNames

    def ClearSubjectFilter(self):
        """ Clear the subject filter. This will result in all subjects being sent.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.ClearSubjectFilter()
        
        See Also: AddToSubjectFilter()
        """
        ret = self.client.ClearSubjectFilter()
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def AddToSubjectFilter(self, subjectName):
        """ Add a subject name to the subject filter.
        Only subjects present in the subject filter will be sent and
        subjects not in the filter will be presented as absent/occluded.

        If no filtered subjects are present, all subjects will be sent.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.AddToSubjectFilter( 'Colin' )
        
        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName

        See Also : ClearSubjectFilter()
        """
        ret = self.client.AddToSubjectFilter( subjectName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )

    def GetSubjectRootSegmentName( self, subjectName ):
        """ Return the name of the root segment for a specified subject.

        This can be passed into segment functions.
        The root segment is the ancestor of all other segments in the subject.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> for subject in client.GetSubjects()
            >>>     client.GetSubjectRootSegmentName( subject )
            Hips

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName

        See Also: GetSegmentCount(), GetSegmentParentName(), GetSegmentChildCount(), GetSegmentChildName()
        """
        ret, name = self.retimer.GetSubjectRootSegmentName( subjectName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return name

    def GetSegmentNames(self, subjectName):
        """ Return a list containing the names of all segments for a specified subject in the DataStream.

        This information can be used in conjunction with GetSegmentName.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> for subject in client.GetSubjects()
            >>>     client.GetSegmentNames( subject )
            [ Hips, Spine, Head ]

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
        
        See Also: GetSubjectName(), GetSegmentName()
        """
        segmentNames = []
        ret, segmentCount = self.retimer.GetSegmentCount( subjectName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for segmentIndex in range( 0, segmentCount ):
            ret, segmentName = self.retimer.GetSegmentName( subjectName, segmentIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            segmentNames.append( segmentName )
        return segmentNames

    def GetSegmentChildren(self, subjectName, segmentName):
        """ Returns a list containing the names of all child segments for a specified subject segment.

        This can be passed into segment functions.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> for subject in client.GetSubjects()
            >>>     root = client.GetSubjectRootSegmentName( subject )
            >>>     client.GetSegmentChildren( subject, root )
            [ Spine ]

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
        
        See Also: GetSegmentCount()
        """
        childNames = []
        ret, childCount = self.retimer.GetSegmentChildCount( subjectName, segmentName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        for childIndex in range( 0, childCount ):
            ret, childName = self.retimer.GetSegmentChildName( subjectName, segmentName, childIndex )
            if ret != CoreClient.Success:
                raise DataStreamException( ret )
            childNames.append( childName )
        return childNames

    def GetSegmentParentName(self, subjectName, segmentName):
        """ Return the name of the parent segment for a specified subject segment.

        If the specified segment is the root segment of the subject then it will return an empty string.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> for subject in client.GetSubjects()
            >>>     root = client.GetSubjectRootSegmentName( subject )
            >>>     client.GetSegmentParentName( subject, root )

            >>>     children = client.GetSegmentChildren( subject, root )
            >>>     for child in children:
            >>>         client.GetSegmentParentName( subject, child )
            Hips

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
        

        See Also: GetSegmentNames(), GetSegmentChildNames(), GetSubjectRootSegmentName()
        """
        ret, name = self.retimer.GetSegmentParentName( subjectName, segmentName )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        return name

    ##\}

    ##\name Static pose
    ## Functions related to subject static pose.
    ##
    ##\{

    def GetSegmentStaticTranslation(self, subjectName, segmentName ):
        """ Return the static pose translation of a subject segment.
        
        The static translation of the segment corresponds to the PRE-POSITION element of the segment in the subject vsk. 
        It is the base setpoint of the segment, and is included in the value returned by GetLocalTranslation.
        If you are required to calculate the amount a segment has moved from its base setpoint, subtract this value from the local
        translation.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentStaticTranslation( 'Alice', 'Pelvis' )
            ( 0, 0, 0 )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
        
        See Also: GetSegmentStaticRotationHelical(), GetSegmentStaticRotationMatrix(), GetSegmentStaticRotationQuaternion(), 
        GetSegmentStaticRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """    
        a = CoreClient.doubleArray( 3 )
        ret = self.retimer.GetSegmentStaticTranslation( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return t

    def GetSegmentStaticRotationHelical(self, subjectName, segmentName):
        """ Return the static pose rotation of a subject segment in helical coordinates.
        The helical coordinates represent a vector whose length is the amount of rotation in radians, and the direction is the axis about which to rotate.
        
        The static rotation of the segment corresponds to the PRE-ORIENTATION element of the segment in the subject vsk. 
        It is the base rotation of the segment, and is included in the value returned by GetLocalRotation*.
        If you are required to calculate the amount a segment has rotated from its base setpoint, subtract this value from the local
        rotation.
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentStaticRotationHelical( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0 )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        See Also: GetSegmentStaticTranslation(), GetSegmentStaticRotationMatrix(), GetSegmentStaticRotationQuaternion(), 
        GetSegmentStaticRotationEulerXYZ(), GetSegmentLocalTranslation, GetSegmentLocalRotationHelical, GetSegmentLocalRotationMatrix, 
        GetSegmentLocalRotationQuaternion, GetSegmentLocalRotationEulerXYZ
        """
        a = CoreClient.doubleArray( 3 )
        ret = self.retimer.GetSegmentStaticRotationHelical( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return t

    def GetSegmentStaticRotationMatrix(self, subjectName, segmentName):
        """ Return the static pose rotation of a subject segment as a 3x3 row-major matrix.
        
        The static rotation of the segment corresponds to the PRE-ORIENTATION element of the segment in the subject vsk. 
        It is the base rotation of the segment, and is included in the value returned by GetLocalRotation*.
        If you are required to calculate the amount a segment has rotated from its base setpoint, subtract this value from the local
        rotation.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentStaticRotationMatrix( 'Alice', 'Pelvis' )
            (( 1.0, 0.0, 0.0 ), ( 0.0, 1.0, 0.0 ), ( 0.0, 0.0, 1.0 ))

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        
        See Also: GetSegmentStaticTranslation(), GetSegmentStaticRotationHelical(), GetSegmentStaticRotationQuaternion(), 
        GetSegmentStaticRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationQuaternion(), 
        GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 9 )
        ret = self.retimer.GetSegmentStaticRotationMatrix( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( ( a[0], a[1], a[2] ), ( a[3], a[4], a[5] ), ( a[6], a[7], a[8] ) )
        return t

    def GetSegmentStaticRotationQuaternion(self, subjectName, segmentName):
        """ Return the static pose rotation of a subject segment in quaternion coordinates.
        
        The quaternion is of the form (x, y, z, w) where w is the real component and x, y and z are the imaginary components. 
        N.B. This is different from that used in many other applications, which use (w, x, y, z).
        
        The static rotation of the segment corresponds to the PRE-ORIENTATION element of the segment in the subject vsk. 
        It is the base rotation of the segment, and is included in the value returned by GetLocalRotation*.
        If you are required to calculate the amount a segment has rotated from its base setpoint, subtract this value from the local
        rotation.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentStaticRotationQuaternion( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0, 1.0 )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        See Also: GetSegmentStaticTranslation(), GetSegmentStaticRotationHelical(), GetSegmentStaticRotationMatrix(), 
        GetSegmentStaticRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """ 
        a = CoreClient.doubleArray( 4 )
        ret = self.retimer.GetSegmentStaticRotationQuaternion( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2], a[3] )
        return t

    def GetSegmentStaticRotationEulerXYZ(self, subjectName, segmentName):
        """ Return the static pose rotation of a subject segment in Euler XYZ coordinates.
        
        The static rotation of the segment corresponds to the PRE-ORIENTATION element of the segment in the subject vsk. 
        It is the base rotation of the segment, and is included in the value returned by GetLocalRotation*.
        If you are required to calculate the amount a segment has rotated from its base setpoint, subtract this value from the local
        rotation.
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentStaticRotationEulerXYZ( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0  )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        See Also: GetSegmentStaticTranslation(), GetSegmentStaticRotationHelical(), GetSegmentStaticRotationMatrix(), 
        GetSegmentStaticRotationQuaternion(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), 
        GetSegmentLocalRotationMatrix(), GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ().
        """
        a = CoreClient.doubleArray( 3 )
        ret = self.retimer.GetSegmentStaticRotationEulerXYZ( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return t


    def GetSegmentStaticScale(self, subjectName, segmentName):
        """ Return a 3D Scale of a subject segment if present. 
        
        Not all applications support subject scale. If the application does not support scale data, an
        exception will be thrown with the error NotSupported.
        If the application supports scale data but none is available for the segment, an exception will be 
        thrown with the error NotPresent.
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentStaticScale( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0 )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               + NotSupported
               + NotPresent
        """
        a = CoreClient.doubleArray( 3 )
        ret = self.retimer.GetSegmentStaticScale( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return t

    ##\}

    ##\name Global pose
    ## Functions related to subject global pose.
    ##
    ##\{    

    def GetSegmentGlobalTranslation( self, subjectName, segmentName ):
        """ Return the translation of a subject segment in global coordinates.

        The translation is of the form ( x, y, z ) where x, y and z are in millimeters with respect to the global origin.
        The function also returns whether the segment is occluded
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentGlobalTranslation( 'Alice', 'Pelvis' )
            (( 0.0, 0.0, 0.0 ), False )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        See Also: GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationMatrix(), GetSegmentGlobalRotationQuaternion(), 
        GetSegmentGlobalRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 3 )
        ret, o = self.retimer.GetSegmentGlobalTranslation( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( a[0], a[1], a[2] )
        return ( p, o )

    def GetSegmentGlobalRotationHelical( self, subjectName, segmentName ):
        """Return the rotation of a subject segment in global helical coordinates.
        
        The function also returns whether the segment is occluded
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentGlobalRotationHelical( 'Alice', 'Pelvis' )
            ( ( 0.0, 0.0, 0.0 ), False )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
        
        See Also: GetSegmentGlobalTranslation(), GetSegmentGlobalRotationMatrix(), GetSegmentGlobalRotationQuaternion(), 
        GetSegmentGlobalRotationEulerXYZ(), GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 3 )
        ret, o = self.retimer.GetSegmentGlobalRotationHelical( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( a[0], a[1], a[2] )
        return ( p, o )

    def GetSegmentGlobalRotationQuaternion( self, subjectName, segmentName ):
        """ Return the rotation of a subject segment in global quaternion coordinates.
        
        The quaternion is of the form (x, y, z, w) where w is the real component and x, y and z are the imaginary components. 
        N.B. This is different from that used in many other applications, which use (w, x, y, z).
        
        The function also returns whether the segment is occluded
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentGlobalRotationQuaternion( 'Alice', 'Pelvis' )
            ( 0.0, 0.0, 0.0, 1.0 ), False )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
         See Also: GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ(), 
         GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 4 )
        ret, o = self.retimer.GetSegmentGlobalRotationQuaternion( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( a[0], a[1], a[2], a[3] )
        return ( p, o )

    def GetSegmentGlobalRotationMatrix( self, subjectName, segmentName ):
        """ Return the rotation of a subject segment as a 3x3 row-major matrix in global coordinates.
        
        The function also returns whether the segment is occluded
                    
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> client.GetSegmentGlobalRotationMatrix( 'Alice', 'Pelvis' )
            ((( 1.0, 0.0, 0.0 ), ( 0.0, 1.0, 0.0 ), ( 0.0, 0.0, 1.0 )), False )

        \throw A DataStreamException class containing the error:
               + NotConnected
               + NoFrame
               + InvalidSubjectName
               + InvalidSegmentName
               
         See Also: GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ(), 
         GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 9 )
        ret, o = self.retimer.GetSegmentGlobalRotationMatrix( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( ( a[0], a[1], a[2] ),( a[3], a[4], a[5] ),( a[6], a[7], a[8] ) )
        return ( p, o )

    def GetSegmentGlobalRotationEulerXYZ( self, subjectName, segmentName ):
        """Return the rotation of a subject segment in global Euler XYZ coordinates.

            >>> import ViconDataStream
            >>> client = ViconDataStream.Client()
            >>> client.Connect('localhost')
            >>> client.GetFrame()
            >>> print( client.GetSegmentGlobalRotationEulerXYZ('H','H') )
            ((0.4981558177968117, -0.3232636229639283, 1.0118097275740245), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName

        \return Tuple containing:
                - The rotation of the segment as a 3 touple (X,Y,Z).
                - Occluded will be True if the segment was absent at this frame. In this case the rotation will be [0,0,0].

        See Also : GetSegmentGlobalTranslation, GetSegmentGlobalRotationHelical...
        """
        a = CoreClient.doubleArray( 3 )
        ret, o = self.retimer.GetSegmentGlobalRotationEulerXYZ( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        p = ( a[0], a[1], a[2] )
        return ( p, o )

    ##\}

    ##\name Local pose
    ## Functions related to subject local pose.
    ##
    ##\{

    def GetSegmentLocalTranslation(self, subjectName, segmentName ):
        """ Return the translation of a subject segment in local coordinates relative to its parent segment.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> print( client.GetSegmentLocalTranslation('Alice','Pelvis') )
            ((0.0, 0.0, 0.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName

        See Also: GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), GetSegmentLocalRotationQuaternion(), 
        GetSegmentLocalRotationEulerXYZ(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationMatrix(), 
        GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """ 
        a = CoreClient.doubleArray( 3 )
        ret, occluded = self.retimer.GetSegmentLocalTranslation( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return ( t, occluded )

    def GetSegmentLocalRotationHelical(self, subjectName, segmentName ):
        """ Return the rotation of a subject segment in local helical coordinates relative to its parent segment.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> print( client.GetSegmentLocalRotationHelical('Alice','Pelvis') )
            ((0.0, 0.0, 0.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName
        
        See Also: GetSegmentLocalTranslation(), GetSegmentLocalRotationMatrix(), GetSegmentLocalRotationQuaternion(), 
        GetSegmentLocalRotationEulerXYZ(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), 
        GetSegmentGlobalRotationMatrix(), GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 3 )
        ret, occluded = self.retimer.GetSegmentLocalRotationHelical( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return ( t, occluded )

    def GetSegmentLocalRotationMatrix(self, subjectName, segmentName ):
        """ Return the rotation row-major matrix of a subject segment in local coordinates relative to its parent segment.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> print( client.GetSegmentLocalRotationMatrix('Alice','Pelvis') )
            (((1.0, 0.0, 0.0), 0.0, 1.0, 0.0), 0.0, 0.0, 1.0)), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName
        
        See Also: GetSegmentLocalTranslation(), GetSegmentLocalRotationQuaternion(), GetSegmentLocalRotationEulerXYZ(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationMatrix() , GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 9 )
        ret, occluded = self.retimer.GetSegmentLocalRotationMatrix( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( ( a[0], a[1], a[2] ),( a[3], a[4], a[5] ),( a[6], a[7], a[8] ) )
        return ( t, occluded )

    def GetSegmentLocalRotationQuaternion(self, subjectName, segmentName ):
        """ Return the rotation of a subject segment in local quaternion coordinates relative to its parent segment.
        The quaternion is of the form (x, y, z, w) where w is the real component and x, y and z are the imaginary components. 
        N.B. This is different from that used in many other applications, which use (w, x, y, z).
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> print( client.GetSegmentLocalRotationQuaternion('Alice','Pelvis') )
            ((0.0, 0.0, 0.0, 1.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName
        
        See Also: GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), 
        GetSegmentLocalRotationEulerXYZ(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), 
        GetSegmentGlobalRotationMatrix(), GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 4 )
        ret, occluded = self.retimer.GetSegmentLocalRotationQuaternion( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2], a[3] )
        return ( t, occluded )

    def GetSegmentLocalRotationEulerXYZ(self, subjectName, segmentName ):
        """ Return the rotation of a subject segment in local Euler XYZ coordinates relative to its parent segment.
        
            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.Connect('localhost')
            >>> client.UpdateFrame()
            >>> print( client.GetSegmentLocalRotationEulerXYZ('Alice','Pelvis') )
            ((0.0, 0.0, 0.0), False)

        \throw A DataStreamException class containing the error:
                + NotConnected
                + Success
                + NoFrame
                + InvalidSubjectName
                + InvalidSegmentName
        
        See Also: GetSegmentLocalTranslation(), GetSegmentLocalRotationHelical(), GetSegmentLocalRotationMatrix(), GetSegmentLocalRotationQuaternion(), GetSegmentGlobalTranslation(), GetSegmentGlobalRotationHelical(), GetSegmentGlobalRotationMatrix() , GetSegmentGlobalRotationQuaternion(), GetSegmentGlobalRotationEulerXYZ()
        """
        a = CoreClient.doubleArray( 3 )
        ret, occluded = self.retimer.GetSegmentLocalRotationEulerXYZ( subjectName, segmentName, a )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
        t = ( a[0], a[1], a[2] )
        return ( t, occluded )

    ##\}
    ##\}

    def SetMaximumPrediction( self, max_prediction):
        """ Sets the maximum amount by which the interpolation engine will predict later than the latest received frame.
        If required to predict by more than this amount, the result LateDataRequested will be returned.

        max_prediction is the maximum amount in milliseconds of prediction that will be permitted.
        This function does not require the datastream to be connected to be called.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.SetMaximumPrediction( 50 )

         """
        self.retimer.SetMaximumPrediction( max_prediction )

    def MaximumPrediction( self ):
        """ Returns the maximum amount by which the interpolation engine will predict later than the latest received frame.
        If required to predict by more than this amount, the result LateDataRequested will be returned.

        The value returned is in milliseconds
        This function does not require the datastream to be connected to be called.

            >>> import ViconDataStream
            >>> client = ViconDataStream.RetimingClient()
            >>> client.MaximumPrediction()
            50

        """
        pred = self.retimer.MaximumPrediction()
        return pred

    def SetTimingLog(self, client_log, stream_log ):
        """  Sets a log file that timing debug information will be written to
        """
        ret = self.client.SetTimingLog( client_log, stream_log )
        if ret != CoreClient.Success:
            raise DataStreamException( ret )
